{"meta":{"title":"爱喝茶的帮主","subtitle":"优雅的写代码...","description":"Java、Android工作学习总结","author":"bangzhu","url":"https://banggu.github.io"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-12-23T11:00:29.128Z","updated":"2018-10-22T04:59:45.517Z","comments":true,"path":"2018/12/23/hello-world/","link":"","permalink":"https://banggu.github.io/2018/12/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"summary_of_process_android_target26","slug":"summary-of-process-android-target26","date":"2018-11-25T09:21:58.000Z","updated":"2018-11-25T09:25:24.814Z","comments":true,"path":"2018/11/25/summary-of-process-android-target26/","link":"","permalink":"https://banggu.github.io/2018/11/25/summary-of-process-android-target26/","excerpt":"","text":"Android Target 26 处理遇到的问题 最近项目升 target26处理，遇到了很多问题，这里总结一下： 1.BrocastReceiver相关 由于 Android 8.0 引入了新的广播接收器限制，注册的隐式广播在运行时将不起作用，因此需要移除大部分的隐式广播。主要的处理方式有以下三种： 隐式广播白名单 使用 JobScheduler 实现类似的功能 使用动态注册的广播 1.1隐式广播白名单 在8.0中还是有部分隐式广播可以继续使用，它们就是“白名单”广播，包括： ACTION_LOCKED_BOOT_COMPLETED, ACTION_BOOT_COMPLETEDACTION_USER_INITIALIZEACTION_LOCALE_CHANGEDACTION_USB_ACCESSORY_ATTACHED, ACTION_USB_ACCESSORY_DETACHED, ACTION_USB_DEVICE_ATTACHED, ACTION_USB_DEVICE_DETACHEDACTION_CONNECTION_STATE_CHANGED, ACTION_CONNECTION_STATE_CHANGED, ACTION_ACL_CONNECTED, ACTION_ACL_DISCONNECTEDACTION_CARRIER_CONFIG_CHANGED,TelephonyIntents.ACTION_*_SUBSCRIPTION_CHANGED, &quot;TelephonyIntents.SECRET_CODE_ACTION&quot;, ACTION_PHONE_STATE_CHANGED, ACTION_PHONE_ACCOUNT_REGISTERED, ACTION_PHONE_ACCOUNT_UNREGISTEREDLOGIN_ACCOUNTS_CHANGED_ACTIONACTION_ACCOUNT_REMOVEDACTION_PACKAGE_DATA_CLEAREDACTION_PACKAGE_FULLY_REMOVEDACTION_NEW_OUTGOING_CALLACTION_DEVICE_OWNER_CHANGEDACTION_EVENT_REMINDERACTION_MEDIA_MOUNTED, ACTION_MEDIA_CHECKING, ACTION_MEDIA_UNMOUNTED, ACTION_MEDIA_EJECT, ACTION_MEDIA_UNMOUNTABLE, ACTION_MEDIA_REMOVED, ACTION_MEDIA_BAD_REMOVALSMS_RECEIVED_ACTION, WAP_PUSH_RECEIVED_ACTION 具体说明可参见官方文档： Implicit Broadcast Exceptions 1.2使用 JobScheduler 实现类似的功能 在许多情况下，之前注册隐式广播可以使用 JobScheduler 实现类似的功能。如设备网络状态变化、设备充电状态变化、低电量等。JobScheduler的用法在下面”后台服务相关“会说明。 1.3使用动态注册的广播 之前用的静态注册的隐式广播可以改为动态注册的方式实现，建议是在Application类中注册，如下所示： CacheReceiver mCacheReceiver = new CacheReceiver();registerReceiver(mCacheReceiver, createIntentFilter( ApplicationId.APPLICATION_ID + &quot;.transaction.BootCompleteReceiver.BOOT_COMPLETED&quot;, ApplicationId.APPLICATION_ID + &quot;.transaction.cachereceiver&quot;, ApplicationId.APPLICATION_ID + &quot;.transaction.cachedata&quot; )); private IntentFilter createIntentFilter(String... actions) &#123; IntentFilter intentFilter = new IntentFilter(); for (String action : actions) &#123; intentFilter.addAction(action); &#125; return intentFilter;&#125; 2.后台服务相关 Android8.0对后台服务做了限制，使得此前一直使用的后台服务（Start Service）无法正常工作。注意是Start Service，Bind Service不受影响，仍可以正常使用。下面是官方文档的说明： 处于前台时，应用可以自由创建和运行前台服务与后台服务。 进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用服务。 在该时间窗结束后，应用将被视为处于 空闲 状态。 此时，系统将停止应用的后台服务，就像应用已经调用服务的“Service.stopSelf()”方法。 如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 startService() 函数，则该函数将引发一个 IllegalStateException。 处理的方式有四种： 对于重要程度不高的服务，try-catch 住 startService() 方法 使用 JobIntentService 代替 IntentService 使用 JobScheduler 使用前台服务代替后台服务 2.1 try-catch 住 startService() 方法 对于重要程度不高的服务，try-catch 住 startService() 方法，不出现崩溃即可，因为系统会有一个持续数分钟的时间窗来启动和处理服务，我们无法知道系统什么时候允许应用创建后台服务。在允许时，系统自动回去启动服务，不允许时，也不会crash。 2.2使用 JobIntentService 代替 IntentService 如果之前的后台服务是用IntentService实现的，则可用JobIntentService代替。 JobIntentService的用法如下： public class InstallMonitorJobIntentService extends JobIntentService &#123; private static final int JOB_ID = 1001; public static void enqueueWork(Context context, Intent work) &#123; if (null == work) &#123; return; &#125; enqueueWork(context, InstallMonitorJobIntentService.class, JOB_ID, work); &#125; @Override protected void onHandleWork(@NonNull Intent intent) &#123; if (null == intent) &#123; return; &#125; checkInstall(intent); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 记得在menifest注册时要申明android.permission.BIND_JOB_SERVICE权限，否则会出现java.lang.IllegalArgumentException &lt;service android:name=&quot;.monitor.InstallMonitorJobIntentService&quot; android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot;/&gt; 2.3 使用 JobScheduler实现短耗时的后台服务 对于短耗时的后台服务，可以使用 JobScheduler实现，JobScheduler的用法和 JobIntentService 很相似，如下： public class InstallMonitorJobService extends JobService &#123; public static final String PACKAGE_NAME_KEY = &quot;package_name_key&quot;; private static final String TAG = InstallMonitorJobService.class.getSimpleName(); private String mPkgName; public static void startScheduleJob (Context context, String pkg) &#123; JobInfo.Builder builder = new JobInfo.Builder(JOB_ID, new ComponentName(context, InstallMonitorJobService.class)); builder.setOverrideDeadline(2000); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); PersistableBundle extras = new PersistableBundle(); extras.putString(InstallMonitorJobService.PACKAGE_NAME_KEY, pkg); builder.setExtras(extras); JobScheduler mJobScheduler = (JobScheduler)context.getSystemService(Context.JOB_SCHEDULER_SERVICE); // 这里就将开始在service里边处理我们配置好的job mJobScheduler.schedule(builder.build()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; @Override public boolean onStartJob(JobParameters params) &#123; if (Loger.isD()) &#123; Log.e(TAG, &quot;InstallMonitorJobService onStartJob&quot;); &#125; mPkgName = params.getExtras().getString(PACKAGE_NAME_KEY); checkInstall(mPkgName); return true; &#125; @Override public boolean onStopJob(JobParameters params) &#123; if (Loger.isD()) &#123; Log.e(TAG, &quot;InstallMonitorJobService onStopJob&quot;); &#125; return false; &#125;&#125; 注意，JobScheduler同样需要在menifest的注册中申明 android.permission.BIND_JOB_SERVICE 权限。 2.4 使用前台服务代替长耗时的后台服务 使用新的 Context.startForegroundService() 方法启动一个前台服务，并且必须在创建服务后的五秒内调用该服务的 startForeground() 函数。否则会出现ANR。 3.权限相关 在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。 对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 我们项目处理target26时遇到过这类异常： Non-fatal Exception: java.lang.SecurityExceptionPermission Denial: opening provider com.android.providers.contacts.ContactsProvider2 from ProcessRecord&#123;ada6f44 14724:com.cjb.tomatoSchedulers/u0a173&#125; (pid=14724, uid=10173) requires android.permission.READ_CONTACTS or android.permission.WRITE_CONTACTSandroid.os.Parcel.readException (Parcel.java:1959)android.content.ContentResolver.registerContentObserver (ContentResolver.java:1919)...android.os.Handler.dispatchMessage (Handler.java:105)android.os.HandlerThread.run (HandlerThread.java:65) 这类异常出现的场景是，应用被按非正常流程启动，比如应用从未打开或从未授权过，此时收到推送或者广播被拉起，进入一个需要使用某些敏感权限的页面，则会出现crash。可以在这些需要授权的地方加入权限判断，若需要申请权限且可以申请（在页面中），则先申请授权；若需要申请且不能申请（在Serviece中，用户不能授权），则关闭当前操作并返回。 4.悬浮窗相关 在Android8.0中，使用 SYSTEM_ALERT_WINDOW 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口： TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERT TYPE_SYSTEM_OVERLAY TYPE_SYSTEM_ERROR 相反，应用必须使用名为 TYPE_APPLICATION_OVERLAY 的新窗口类型。 使用 TYPE_APPLICATION_OVERLAY 窗口类型显示应用的提醒窗口时，请记住新窗口类型的以下特性： 应用的提醒窗口始终显示在状态栏和输入法等关键系统窗口的下面。 系统可以移动使用 TYPE_APPLICATION_OVERLAY 窗口类型的窗口或调整其大小，以改善屏幕显示效果。 通过打开通知栏，用户可以访问设置来阻止应用显示使用 TYPE_APPLICATION_OVERLAY 窗口类型显示的提醒窗口。 5.通知渠道相关 Android 8.0 重新设计了通知，从8.0开始，通知都必须通过通知渠道推送。否则，通知将不会出现在通知栏且会报错。 创建通知栏的代码如下所示： private void createNotificationChannel(int channelId) &#123; // Create the NotificationChannel, but only on API 26+ because // the NotificationChannel class is new and not in the support library if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; CharSequence name = getString(R.string.channel_name); String description = getString(R.string.channel_description); int importance = NotificationManager.IMPORTANCE_DEFAULT; NotificationChannel channel = new NotificationChannel(channelId, name, importance); channel.setDescription(description); // Register the channel with the system; you can't change the importance // or other notification behaviors after this NotificationManager notificationManager = getSystemService(NotificationManager.class); notificationManager.createNotificationChannel(channel); &#125;&#125; 用原先的值创建已经存在的渠道不执行任何操作，所以可以在Application类中创建渠道。 通过通知渠道推送通知的代码如下： createNotificationChannel(channelId, MyApp.getApp().getString(R.string.channel_name_push), NotificationManager.IMPORTANCE_HIGH , sound);NotificationCompat.Builder builder = new NotificationCompat.Builder(context, channelId);builder.setGroup( SelfMAppUrlActionNotiIdVariable.NOTIFICATION_GROUP_KEY_NEW_MESSAGE) .setSmallIcon(iconRes) .setTicker(showText) .setWhen(timeMillis) .setLargeIcon(largeIcon) .setAutoCancel(true) setContentTitle(msgTitle) .setContentText(msgDsp) .setContentIntent(pendingIntent) .setDeleteIntent(deleteIntent);Notification notification = builder.build();NotificationManager nm = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);nm.notify(notifyId, notification); 注意在将通知推送到通知渠道之后，该通知的属性就不能修改了，包括震动、铃声这些，所以若需要修改则只能新建一个渠道。还有每次新建渠道之前记得删除掉之前的渠道，注意只删除那些没有通知的渠道。 用下面的方法删除： public static void deleteNoNumberNotification(String newChannelId) &#123; NotificationManager nm = (NotificationManager) MmsApp.getMmsApp().getSystemService(NOTIFICATION_SERVICE); if (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.O) &#123; return; &#125; List&lt;NotificationChannel&gt; notificationChannels = nm.getNotificationChannels(); if (notificationChannels == null) &#123; return; &#125; for (NotificationChannel channel : notificationChannels) &#123; if (channel.getId() == null || channel.getId().equals(newChannelId)) &#123; continue; &#125; int notificationNumbers = getNotificationNumbers(nm, channel.getId()); if (notificationNumbers == 0) &#123; nm.deleteNotificationChannel(channel.getId()); &#125; &#125;&#125;private static int getNotificationNumbers(NotificationManager mNotificationManager, String channelId) &#123; if (mNotificationManager == null || TextUtils.isEmpty(channelId)) &#123; return -1; &#125; int numbers = 0; StatusBarNotification[] activeNotifications = mNotificationManager.getActiveNotifications(); for (StatusBarNotification item : activeNotifications) &#123; Notification notification = item.getNotification(); if (notification != null) &#123; if (channelId.equals(notification.getChannelId())) &#123; numbers++; &#125; &#125; &#125; return numbers; &#125; 我们项目在处理自定义铃声时就遇到这个问题，之前的通知铃声是直接通过notification来实现的，没有使用通知渠道来处理消息通知，所以通知铃声会无法生效。改为用通知渠道推送通知后，就可以了。","categories":[],"tags":[{"name":"Android Learning","slug":"Android-Learning","permalink":"https://banggu.github.io/tags/Android-Learning/"}]},{"title":"androidTextLinearColorGradient","slug":"androidTextLinearColorGradient","date":"2018-10-22T15:29:23.000Z","updated":"2018-11-25T07:06:15.636Z","comments":true,"path":"2018/10/22/androidTextLinearColorGradient/","link":"","permalink":"https://banggu.github.io/2018/10/22/androidTextLinearColorGradient/","excerpt":"","text":"线性颜色渐变 最近遇到一个需要用到线性颜色渐变的需求，而且后期还可能改为颜色“闪动”的效果。 预期效果如下： ​ 于是就去研究了一下线性颜色渐变，这里做下总结。 实现线性颜色渐变，有四种方式： 1.自定义View继承自TextView，获取View 的Paint对象，并给Paint对象设置渐变。 2.用canvas#drawText方法，在onDraw方法中设置渐变并绘制。 3.用StaticLayout实现多行文本颜色渐变。 4.用DynamicLayout实现多行文本颜色渐变。 ​ 下面详细说明这四种方式： 1.直接获取Paint对象，并给Paint设置LinearGradient public class LinearGradientTextView extends TextView &#123; private LinearGradient mLinearGradient; private Paint mPaint; private int mViewWidth = 0; public LinearGradientTextView1(Context context) &#123; this(context, null); &#125; public LinearGradientTextView1(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LinearGradientTextView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mViewWidth == 0) &#123; mViewWidth = getMeasuredWidth(); mLinearGradient = new LinearGradient(0, 0, mViewWidth, 0, new int[]&#123;0xFFFA3DB3, 0xFF3D53FB&#125;, null, Shader.TileMode.REPEAT); mPaint = getPaint(); mPaint.setShader(mLinearGradient); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; setGravity(Gravity.LEFT); super.onDraw(canvas); &#125;&#125; 运行效果如下图： ​ 代码很简单，就是在onSizeChanged获取mPaint,并给mPaint设置线性渐变，然后在onDraw 方法里绘制出来。如果你只是想在TextView中显示渐变颜色的文本，这种方式是最简单的。 2.canvas#drawText实现颜色渐变 这种方式更多用于自定义绘图或者进行图片处理时绘制文字。当然也可以用于TextView 绘制渐变文本。下面给出的例子是在ImageView中绘制颜色渐变的文本： public class GradientImageView extends ImageView &#123; private LinearGradient mLinearGradient; private Paint mPaint; private int mViewWidth = 0; private String mSrcString; public GradientImageView(Context context) &#123; this(context, null); &#125; public GradientImageView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public GradientImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mViewWidth == 0) &#123; mViewWidth = getMeasuredWidth(); mLinearGradient = new LinearGradient(0, 0, mViewWidth, 0, new int[]&#123;0xFFFA3DB3, 0xFF3D53FB&#125;, null, Shader.TileMode.REPEAT); mPaint = new Paint(); mPaint.setTextSize(ScreenUtil.dpToPx(getResources(), 16)); mPaint.setShader(mLinearGradient); mSrcString = &quot;there are several linearGradient lines:+&quot; + &quot;\\n&quot; + &quot;This is the first line of gradient text&quot; + &quot;\\n&quot; + &quot;this is the second line of gradient text&quot;; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawText(mSrcString, 10, 300, mPaint); &#125;&#125; 运行结果如下图： 需要注意的是，这种方式实现的渐变文本，是不能换行的。也就是说，不管文本有多长，都只能一行显 示（例子中就是把三行的字符串显示为一行） 3.用StaticLayout实现多行文本颜色渐变 StaticLayout是一个用来处理文本换行的控件，可以用它来实现多行文本颜色渐变。 StaticLayout常用的构造函数是这个： public StaticLayout (CharSequence source, TextPaint paint, int width, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad) 还有两个不常用的： public StaticLayout(CharSequence source, int bufstart, int bufend, TextPaint paint, int outerwidth, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad) public StaticLayout(CharSequence source, int bufstart, int bufend, TextPaint paint, int outerwidth, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad, TextUtils.TruncateAt ellipsize, int ellipsizedWidth) 在android api 28 之后，上面几个构造函数都将被废弃，将使用StaticLayout.Builder替代。StaticLayout.Builder 的用法也很简单，就是先调用 StaticLayout#obtain方法构造StaticLayout.Builder对象，在调用Builder对象的一 系列seter方法，最后调用build()方法。详细请看官方文档： StaticLayout.Builder用法 下面说明一下各个参数的含义： source： 要显示的文本 bufstart：要处理文本的开始字符位置 bufend：要处理文本的结束字符位置 paint：画笔对象 width：文本宽度，超过这个区域会自动换行 outerwidth：换行宽度，超过这个宽度会自动换行 align：对齐方式 spacingmult：行间距，通常设置为1.0f，设置了这个值后，行间距将变为默认间距乘以这个数值，如1.5 表示1.5倍行间距 spacingadd：行间距增加值，最终的行间距 = 默认间距 * spacingmult + spacingadd includepad：设置是否包括超出字体上升和下降的额外空间，一般设置为true，设置了true之后，文本会 垂直居中显示，可避免在某些多语言下，文案被裁剪。 ellipsize： 当文本超出区域或者行数超出限制时，省略的显示位置 ellipsizedWidth：显示省略的那一行可显示文本的宽度，设置0则那一行显示为 … 下面进入正题，看下怎么用 StaticLayout显示多行颜色渐变，下面是主要的代码： @Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mViewWidth == 0) &#123; mViewWidth = getMeasuredWidth(); mLinearGradient = new LinearGradient(0, 0, mViewWidth, 0, new int[]&#123;0xFFD70F00, 0xFFD53A02, 0xFFDB9501, 0xFF3C9B03, 0xFF04C0AF, 0xFF020098, 0xFF4C0177&#125;, null, Shader.TileMode.REPEAT); mSrcString = getResources().getString(R.string.home_lineargradient_text); mTextPaint = new TextPaint(); mTextPaint.setTextSize(ScreenUtil.dpToPx(getResources(), 20)); mTextPaint.setShader(mLinearGradient); mStaticLayout = new StaticLayout(mSrcString, 0, 120, mTextPaint, mViewWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, true, TextUtils.TruncateAt.END, ScreenUtil.dpToPx(getResources(), 10)); &#125;&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; setGravity(Gravity.LEFT); mStaticLayout.draw(canvas);&#125; 在创建StaticLayout的时候，把mLinearGradient设置进去，再在onDraw方法中调用 StaticLayout#draw方法， 就能实现多行的颜色渐变。这里需要注意的是，StaticLayout只能处理那些不能被再次编辑的文本，也就是说 它处理的文本是固定的，不能改变的，如果要处理可以改变的文本，请使用DynamicLayout。 运行效果如下图所示： 4.用DynamicLayout实现线性颜色渐变 DynamicLayout也是一个处理文本换行的控件，它和StaticLayout的用法几乎一模一样。区别就是，DynamicLayout可以处理可编辑的文本，也就是说它处理的文本可以改变。关于它的构造方法及参数的说明请参见StaticLyaout，此处不再赘述。 在DynamicLayout的构造方法的源码中，有这么一段代码（只截取关键代码） public DynamicLayout(CharSequence base, CharSequence display, TextPaint paint, int width, Alignment align, TextDirectionHeuristic textDir, float spacingmult, float spacingadd, boolean includepad, int breakStrategy, int hyphenationFrequency, int justificationMode, TextUtils.TruncateAt ellipsize, int ellipsizedWidth) &#123; ....... if (base instanceof Spannable) &#123; if (mWatcher == null) mWatcher = new ChangeWatcher(this); // Strip out any watchers for other DynamicLayouts. Spannable sp = (Spannable) base; ChangeWatcher[] spans = sp.getSpans(0, sp.length(), ChangeWatcher.class); for (int i = 0; i &lt; spans.length; i++) sp.removeSpan(spans[i]); sp.setSpan(mWatcher, 0, base.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE | (PRIORITY &lt;&lt; Spannable.SPAN_PRIORITY_SHIFT)); &#125; &#125; 当传入构造方法的base是实现了 Spannable接口的实例时，DynamicLayout会自动给这个base设置ChangeWatcher监听器，ChangeWatcher实际上就是一个TextWatcher接口，用于监听base序列的改变。当base改变时，ChangeWatcher#onSpanChanged方法会回调，然后去刷新DynamicLayout的布局。这也就是为什么DynamicLayout能处理可编辑文本的原因。 说回正题，用DynamicLayout实现多行渐变文本也很简单，关键代码如下： @Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mViewWidth == 0) &#123; mViewWidth = getMeasuredWidth(); mLinearGradient = new LinearGradient(0, 0, mViewWidth, 0, new int[]&#123;0xFFD70F00, 0xFFD53A02, 0xFFDB9501, 0xFF3C9B03, 0xFF04C0AF, 0xFF020098, 0xFF4C0177&#125;, null, Shader.TileMode.REPEAT); mSrcString = getResources().getString(R.string.home_lineargradient_text); mSpannableStringBuilder = new SpannableStringBuilder(mSrcString+&quot;\\n&quot;); mTextPaint = new TextPaint(); mTextPaint.setTextSize(ScreenUtil.dpToPx(getResources(), 16)); mTextPaint.setShader(mLinearGradient); mDynamicLayout = new DynamicLayout(mSpannableStringBuilder, mTextPaint, mViewWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, true); setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mSpannableStringBuilder.append(&quot;crazy English liyang !&quot; + &quot;\\n&quot;); postInvalidate(); &#125; &#125;); &#125;&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(10, 300); mDynamicLayout.draw(canvas);&#125; 代码中给这个View设置了点击监听，当点击这个View时，它的文本会增加一行，其他的代码和StaticLayout的相似，不做介绍了。运行结果如下： 当点击图片后，会出现多一行文本，如图： 拓展 上面总结了四种实现线性颜色渐变的方式，但是都只能实现“静止”的颜色渐变，没法实现“动态”的渐变。为了以后 能 反手给设计师一巴掌 （不，是满足设计师的要求），下面说明如何实现“动态的渐变”。 思路也简单，就是让“静止的渐变”每隔一定时间，就位移一定距离，然后刷新重绘，这样就有动态的效果了。下面 看看关键代码： @Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mViewWidth == 0) &#123; mViewWidth = getMeasuredWidth(); mLinearMatrix = new Matrix(); mLinearGradient = new LinearGradient(0, 0, mViewWidth, 0, new int[]&#123;0xFFD70F00, 0xFFD53A02, 0xFFDB9501, 0xFF3C9B03, 0xFF04C0AF, 0xFF020098, 0xFF4C0177&#125;, null, Shader.TileMode.REPEAT); mSrcString = getResources().getString(R.string.home_lineargradient_text); mTextPaint = new TextPaint(); mTextPaint.setTextSize(ScreenUtil.dpToPx(getResources(), 20)); mTextPaint.setShader(mLinearGradient); mStaticLayout = new StaticLayout(mSrcString, mTextPaint, mViewWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, true); &#125;&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; if (mLinearMatrix != null) &#123; mTranslate += mViewWidth / 5; if (mTranslate &gt; 2 * mViewWidth) &#123; mTranslate = -mViewWidth; &#125; mLinearMatrix.setTranslate(mTranslate, 0); mLinearGradient.setLocalMatrix(mLinearMatrix); canvas.translate(0, 10); mStaticLayout.draw(canvas); postInvalidateDelayed(50); &#125;&#125; 这里通过Matrix对象，把位移每隔50毫秒设置给LinearGradient对象，然后再刷新重绘。这里要注意，要给mTranslate设置一个范围（代码中是设置 2*mViewWidth），不然mTranslate的值一直增大，可能造成数值溢出。运行效果如下： 以上就是我所总结的实现线性颜色渐变的方法。有不同意见的朋友，欢迎交流指教。","categories":[{"name":"Android Learning","slug":"Android-Learning","permalink":"https://banggu.github.io/categories/Android-Learning/"}],"tags":[{"name":"Android Text LinearGradient","slug":"Android-Text-LinearGradient","permalink":"https://banggu.github.io/tags/Android-Text-LinearGradient/"}]}]}